#!/usr/bin/python
# required python 3
# pep8 --ignore=E501,E701
#
# mpegts v1.0 - Copyright (C) 2016 Ciriaco Garcia de Celis
# Utility to handle multiplexed MPEG-TS files captured from raw DVB sources
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import stat
import sys
import subprocess
import re
from datetime import timedelta
from collections import OrderedDict, defaultdict
from itertools import chain

inputMode = os.fstat(sys.stdin.fileno()).st_mode
fromStdin = stat.S_ISFIFO(inputMode) or stat.S_ISREG(inputMode)
varg = 1 if fromStdin else 2

if len(sys.argv) < varg:
    print('\n'
          '  mpegts v1.1 - Copyright (C) 2016 Ciriaco Garcia de Celis\n'
          '  Utility to handle multiplexed MPEG-TS files captured from raw DVB sources\n\n'
          '    ' + os.path.basename(sys.argv[0]) + ' input.mts [channel [operation ...]]\n\n'
          '      channel (omit to list all channels):\n'
          '          "channel_name" or channel_ID\n\n'
          '      operation (omit to show the streams in the selected channel):\n'
          '          play                 [start [end]] (reproduce the channel)\n'
          '          save     output.ts   [start [end]] (extract channel; omits teletext)\n'
          '          compress output.mkv  [start [end]] (HQ vp9 encoding; with subtitles)\n'
          '          compress output.webm [start [end]] (HQ vp9 encoding; omits subtitles)\n\n'
          '      Notes: Optional <start> and <end> times (absolute, not from 0) in seconds\n'
          '             Input and/or output files must be omitted when redirection is used\n')
    exit(1)

inFile = '-' if fromStdin else sys.argv[1]

proc = subprocess.Popen(['ffprobe',
                         '-v', 'quiet',
                         '-of', 'compact',
                         '-show_programs',  # also reports streams (without subtitles lang if -show_streams isn't set)
                         '-show_streams',  # this duplicates streams listing when -show_programs is set
                         '-show_entries', 'format',  # for duration (when not available per stream)
                         '-' if fromStdin else 'file:' + inFile],
                        stdout=subprocess.PIPE)

channels = {}
channelStreams = defaultdict(list)
streams = {}
lastChannelName = None
nb_streams = 0
fileDuration = None

while True:
    input = proc.stdout.readline()
    if not input: break
    line = re.sub('\\x05|\\n', '', input.decode("utf-8"))
    if len(line) < 1:
        nb_streams = 0  # ffprobe bug in programs lookup with some files
        continue
    data = dict([(x.split('=') + [None])[:2] for x in line.split('|')])
    if 'format' in data:
        if 'duration' in data: fileDuration = data['duration'] if data['duration'] != 'N/A' else None
    elif 'program_id' in data:
        if nb_streams == 0:
            nb_streams = int(data['nb_streams'])
        if 'tag:service_name' in data:
            lastChannelName = data['tag:service_name'].lower()
            channels[lastChannelName] = data
    elif nb_streams > 0:
        nb_streams -= 1
        channelStreams[lastChannelName].append(data['index'])
    elif 'index' in data:
        streams[data['index']] = data

proc.wait()
if proc.returncode != 0:
    print('error reading', inFile)
    exit(proc.returncode)

channelName = sys.argv[varg] if len(sys.argv) > varg else None

if channels and not channelName:
    longestChannel = max(len(x) for x in channels)
    sortedChannels = OrderedDict(sorted(channels.items(), key=lambda i: i[0].casefold()))
    for channel in sortedChannels.values():
        channelName = channel['tag:service_name']
        nameTellsProvider = re.match(channel['tag:service_provider'], channelName, re.IGNORECASE)
        print('ID {0:>4} ({1:>2} streams) {2:{3}}{4}'.format(
              channel['program_id'],
              channel['nb_streams'],
              channelName, longestChannel,
              '' if nameTellsProvider else ' (%s)' % channel['tag:service_provider']
              ))
    exit(0)

if channelName and channelName.isnumeric():
    channelName = dict(((prop['program_id'], prop['tag:service_name'])
                       for name, prop in channels.items())).get(channelName, channelName)

videoPids = []
audioPids = []
audioStartTime = 0
subtitlePids = []

showStreams = not len(sys.argv) > varg + 1

if channelName and channelName.lower() not in channelStreams:
    print('channel "%s" not found' % channelName)
    exit(1)
else:
    if channelName and showStreams: print(channelName)
    for streamId in (channelStreams[channelName.lower()] if channelName else streams.keys()):
        stream = streams[streamId]
        if 'codec_type' not in stream: continue
        isUnknown = stream['codec_type'] == 'unknown'
        isVideo = stream['codec_type'] == 'video'
        isAudio = stream['codec_type'] == 'audio'
        isImpaired = 'disposition:visual_impaired' in stream and stream['disposition:visual_impaired'] == '1'
        if isUnknown or (isAudio and isImpaired): continue
        pid = None if 'id' not in stream or stream['id'] == 'N/A' else stream['id']
        if showStreams:
            duration = stream['duration'] if 'duration' in stream and stream['duration'] != 'N/A' else None
            if not duration and (isVideo or isAudio): duration = fileDuration
            print("{0} {1}={2} {3:4} [{4}]".format(
                stream['codec_type'],
                'PID' if pid else 'IDX',
                pid if pid else stream['index'],
                stream['codec_name'],
                "{:0>8}".format(str(timedelta(seconds=int(float(duration))))) if duration else 'N/A'),
                end=' ')
        if isVideo:
            if pid: videoPids.append(pid)
            if showStreams:
                print(stream['width'] + 'x' + stream['height'],
                      '' if 'display_aspect_ratio' not in stream else stream['display_aspect_ratio'])
        elif isAudio:
            if pid: audioPids.append(pid)
            if 'start_time' in stream and audioStartTime == 0: audioStartTime = float(stream['start_time'])
            if showStreams:
                print('' if 'tag:language' not in stream else '(%s)' % stream['tag:language'],
                      '' if 'channel_layout' not in stream else stream['channel_layout'],
                      '' if 'channels' not in stream else stream['channels'],
                      '' if 'bit_rate' not in stream else stream['bit_rate'])
        elif stream['codec_type'] == 'subtitle':
            if pid and stream['codec_name'] == 'dvbsub': subtitlePids.append(pid)
            if showStreams:
                print('' if 'tag:language' not in stream else '(%s)' % stream['tag:language'])

if showStreams:
    exit(0)
elif len(videoPids) < 1 and len(audioPids) < 1:
    print('no video or audio PIDs found in the file')
    exit(1)


def seek(argc, opt, lg=None):
    return [] if len(sys.argv) < argc + 1 else \
           [opt, str(float(sys.argv[argc]) - (lg if lg else float(sys.argv[argc - 1])))]

operation = sys.argv[varg + 1].lower()
isPlay = operation == 'play'
isSave = operation == 'save'
isCompress = operation == 'compress'

if isPlay:
    cmd = ['ffplay', '-f', 'mpegts']
    cmd.extend(seek(varg + 2, '-ss', audioStartTime))
    cmd.extend(seek(varg + 3, '-t'))
    cmd.extend(['-vst', 'i:' + videoPids[0]] if len(videoPids) > 0 else ['-vn', '-nodisp'])
    cmd.extend(['-ast', 'i:' + audioPids[0]] if len(audioPids) > 0 else ['-an'])
    cmd.extend(['-sn', '-' if fromStdin else 'file:' + inFile])
elif (isSave or isCompress):
    outputMode = os.fstat(sys.stdout.fileno()).st_mode
    toStdout = stat.S_ISFIFO(outputMode) or stat.S_ISREG(outputMode)
    if toStdout:
        output, ext = ('-', '')
    else:
        if len(sys.argv) < varg + 3:
            print('missing output file argument')
            exit(1)
        output, ext = os.path.splitext(sys.argv[varg + 2])
        varg += 1
    cmd = ['ffmpeg']
    cmd.extend(['-i', '-' if fromStdin else 'file:' + inFile])
    cmd.extend(seek(varg + 2, '-ss', audioStartTime))
    cmd.extend(seek(varg + 3, '-t'))
    for pid in chain(videoPids, audioPids, [] if ext == '.webm' else subtitlePids):
        cmd.append('-map')
        cmd.append('i:' + pid)
    if isSave:
        cmd.extend(['-c', 'copy'])
    else:
        cmd.extend(['-threads', str(2 if sys.version_info < (3, 4) else os.cpu_count())])
        cmd.extend(['-c:v', 'libvpx-vp9',  # perceptually betters h265 at high compression
                    '-crf', '32', '-b:v', '2.5M',  # very high (but constrained) quality
                    '-g', '300'])  # proper seek in some players
        cmd.extend(['-c:a', 'libopus',  # webm requirement and much better than mp3
                    '-b:a', '96k',
                    '-c:s', 'copy'])
        os.nice(19)
    if toStdout:
        cmd.extend(['-f', 'mpegts' if isSave else 'matroska', '-'])
    else:
        if fromStdin: cmd.append('-y')
        if isCompress and ext != '.mkv' and ext != '.webm': ext = None
        if not ext: ext = '.mkv' if len(subtitlePids) > 0 else '.webm'
        cmd.append('file:' + output + ext)
else:
    print('unknown operation "%s"' % operation)
    exit(1)

if subprocess.call(cmd) == 0:
    if (isSave or isCompress) and not (fromStdin or toStdout):
        finf = os.stat(inFile)
        os.utime(output + ext, (finf.st_atime, finf.st_mtime))
